This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-02T17:05:01.253Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
services/
  ws.js
.env.example
.gitignore
index.js
package.json
README.md
websocket.js

================================================================
Files
================================================================

================
File: services/ws.js
================
const WebSocket = require('ws');
const EventEmitter = require('events');

module.exports = class WebSocketService {
  constructor(wsUrl) {
    this.wsUrl = wsUrl;
    this.socket = null;
    this.emitter = new EventEmitter();
    this.emitter.setMaxListeners(0);
    this.subscribedRooms = new Set();
    this.connect();
  }

  connect() {
    this.socket = new WebSocket(this.wsUrl);

    this.socket.on("open", () => {
      this.resubscribeToRooms();
    });

    this.socket.on("message", (data) => {
      try {
        const message = JSON.parse(data);
        if (message.type === "message") {
          this.emitter.emit(message.room, message.data);
        }
      } catch (error) {
        console.error("Error processing message:", error);
      }
    });

    this.socket.on("close", () => {
      console.info("Disconnected from WebSocket server");
      setTimeout(() => this.connect(), 5000);
    });
  }

  joinRoom(room) {
    this.subscribedRooms.add(room);
    if (this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify({ type: "join", room }));
    }
  }

  leaveRoom(room) {
    this.subscribedRooms.delete(room);
    if (this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify({ type: "leave", room }));
    }
  }

  on(room, listener) {
    this.emitter.on(room, listener);
  }

  resubscribeToRooms() {
    if (this.socket.readyState === WebSocket.OPEN) {
      for (const room of this.subscribedRooms) {
        this.socket.send(JSON.stringify({ type: "join", room }));
      }
    }
  }
}

================
File: .env.example
================
# Bot Configuration
AMOUNT=0.001
DELAY=1000
MONITOR_INTERVAL=1000
SLIPPAGE=25
PRIORITY_FEE=0.00005
JITO=false
RPC_URL="https://rpc-mainnet.solanatracker/?api_key=xxxx" # Your RPC URL or get one here. https://www.solanatracker.io/solana-rpc
WS_URL="wss://websocket-example.com" # Websocket URL from Solana Tracker: https://docs.solanatracker.io/public-data-api/websocket

# Token Filtering
MIN_LIQUIDITY=1000
MAX_LIQUIDITY=1000000
MIN_MARKET_CAP=2000
MAX_MARKET_CAP=10000000
MIN_RISK_SCORE=0
MAX_RISK_SCORE=8
REQUIRE_SOCIAL_DATA=false

# PnL Thresholds
MAX_NEGATIVE_PNL=-50
MAX_POSITIVE_PNL=5

# Markets
MARKETS=raydium,orca,pumpfun,moonshot,raydium-cpmm

# Wallet
PRIVATE_KEY=YOUR_PRIVATE_KEY

# API Key from Solana Tarcker
API_KEY=507c5ec3-2d75-404b-b3cf-xxxxxx #Your API Key from Solana Tracker (https://www.solanatracker.io/data-api)

================
File: .gitignore
================
.env
node_modules
trading-bot.log
positions.json
sold_positions.json

================
File: index.js
================
require("dotenv").config();
const { SolanaTracker } = require("solana-swap");
const { Keypair, PublicKey, Connection } = require("@solana/web3.js");
const bs58 = require("bs58");
const winston = require("winston");
const chalk = require("chalk");
const axios = require("axios");
const fs = require("fs").promises;

const session = axios.create({
  baseURL: "https://data.solanatracker.io/",
  timeout: 10000,
  headers: { "x-api-key": process.env.API_KEY },
});

const sleep = (ms) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};

const logger = winston.createLogger({
  level: "info",
  format: winston.format.combine(
    winston.format.timestamp({
      format: "YYYY-MM-DD HH:mm:ss",
    }),
    winston.format.printf(
      (info) => `${info.timestamp} ${info.level}: ${info.message}`
    )
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: "trading-bot.log" }),
  ],
});

class TradingBot {
  constructor() {
    this.config = {
      amount: parseFloat(process.env.AMOUNT),
      delay: parseInt(process.env.DELAY),
      monitorInterval: parseInt(process.env.MONITOR_INTERVAL),
      slippage: parseInt(process.env.SLIPPAGE),
      priorityFee: parseFloat(process.env.PRIORITY_FEE),
      useJito: process.env.JITO === "true",
      rpcUrl: process.env.RPC_URL,
      minLiquidity: parseFloat(process.env.MIN_LIQUIDITY) || 0,
      maxLiquidity: parseFloat(process.env.MAX_LIQUIDITY) || Infinity,
      minMarketCap: parseFloat(process.env.MIN_MARKET_CAP) || 0,
      maxMarketCap: parseFloat(process.env.MAX_MARKET_CAP) || Infinity,
      minRiskScore: parseInt(process.env.MIN_RISK_SCORE) || 0,
      maxRiskScore: parseInt(process.env.MAX_RISK_SCORE) || 10,
      requireSocialData: process.env.REQUIRE_SOCIAL_DATA === "true",
      maxNegativePnL: parseFloat(process.env.MAX_NEGATIVE_PNL) || -Infinity,
      maxPositivePnL: parseFloat(process.env.MAX_POSITIVE_PNL) || Infinity,
      markets: process.env.MARKETS?.split(",").map((m) => m.trim()) || ['raydium', 'orca', 'pumpfun', 'moonshot', 'raydium-cpmm'],
    };

    this.privateKey = process.env.PRIVATE_KEY;
    this.SOL_ADDRESS = "So11111111111111111111111111111111111111112";
    this.positions = new Map();
    this.positionsFile = "positions.json";
    this.soldPositionsFile = "sold_positions.json";
    this.soldPositions = [];
    this.seenTokens = new Set();
    this.buyingTokens = new Set();
    this.sellingPositions = new Set();

    this.connection = new Connection(this.config.rpcUrl);
  }

  async initialize() {
    this.keypair = Keypair.fromSecretKey(bs58.decode ? bs58.decode (this.privateKey): bs58.default.decode(this.privateKey));
    this.solanaTracker = new SolanaTracker(this.keypair, this.config.rpcUrl);
    await this.loadPositions();
    await this.loadSoldPositions();
  }

  async fetchTokens() {
    try {
      const response = await session.get("/tokens/latest");
      return response.data;
    } catch (error) {
      logger.error(`Error fetching token data [${error?.response?.data || error}]`);
      return [];
    }
  }

  async fetchTokenData(tokenId) {
    try {
      const response = await session.get(`/tokens/${tokenId}`);
      return response.data;
    } catch (error) {
      logger.error(`Error fetching token data [${error?.response?.data || error}]`);
      return null
    }
  }

  filterTokens(tokens) {
    return tokens.filter((token) => {
      const pool = token.pools[0];
      const liquidity = pool.liquidity.usd;
      const marketCap = pool.marketCap.usd;
      const riskScore = token.risk.score;
      const hasSocialData = !!(
        token.token.twitter ||
        token.token.telegram ||
        token.token.website
      );
      const isInAllowedMarket = this.config.markets.includes(pool.market);

      return (
        liquidity >= this.config.minLiquidity &&
        liquidity <= this.config.maxLiquidity &&
        marketCap >= this.config.minMarketCap &&
        marketCap <= this.config.maxMarketCap &&
        riskScore >= this.config.minRiskScore &&
        riskScore <= this.config.maxRiskScore &&
        (!this.config.requireSocialData || hasSocialData) &&
        isInAllowedMarket &&
        !this.seenTokens.has(token.token.mint) &&
        !this.buyingTokens.has(token.token.mint)
      );
    });
  }

  async getWalletAmount(wallet, mint, retries = 3) {
    await sleep(5000);
    for (let attempt = 0; attempt <= retries; attempt++) {
      try {
        const tokenAccountInfo =
          await this.connection.getParsedTokenAccountsByOwner(
            new PublicKey(wallet),
            {
              mint: new PublicKey(mint),
            }
          );

        if (tokenAccountInfo.value) {
          const balance =
            tokenAccountInfo.value[0].account.data.parsed.info.tokenAmount
              .uiAmount;

          if (balance > 0) {
            return balance;
          }
        }

        if (attempt < retries) {
          await sleep(10000);
        }
      } catch (error) {
        if (attempt < retries) {
          await sleep(10000);
        } else {
          logger.error(
            `All attempts failed. Error getting wallet amount for token ${mint}:`,
            error
          );
        }
      }
    }

    logger.warn(
      `Failed to get wallet amount for token ${mint} after ${retries} retries.`
    );
    return null;
  }

  async performSwap(token, isBuy) {
    logger.info(
      `${
        isBuy ? chalk.white("[BUYING]") : chalk.white("[SELLING]")
      } [${this.keypair.publicKey.toBase58()}] [${token.token.symbol}] [${
        token.token.mint
      }]`
    );
    const { amount, slippage, priorityFee } = this.config;
    const [fromToken, toToken] = isBuy
      ? [this.SOL_ADDRESS, token.token.mint]
      : [token.token.mint, this.SOL_ADDRESS];

    try {
      let swapAmount;
      if (isBuy) {
        swapAmount = amount;
      } else {
        const position = this.positions.get(token.token.mint);
        if (!position) {
          logger.error(
            `No position found for ${token.token.symbol} when trying to sell`
          );
          return false;
        }
        swapAmount = position.amount;
      }

      const swapResponse = await this.solanaTracker.getSwapInstructions(
        fromToken,
        toToken,
        swapAmount,
        slippage,
        this.keypair.publicKey.toBase58(),
        priorityFee
      );

      const swapOptions = this.buildSwapOptions();
      const txid = await this.solanaTracker.performSwap(
        swapResponse,
        swapOptions
      );
      this.logTransaction(txid, isBuy, token);

      if (isBuy) {
        const tokenAmount = await this.getWalletAmount(
          this.keypair.publicKey.toBase58(),
          token.token.mint
        );
        if (!tokenAmount) {
          logger.error(
            `Swap failed ${token.token.mint}`
          );
          return false;
        }
        this.positions.set(token.token.mint, {
          txid,
          symbol: token.token.symbol,
          entryPrice: token.pools[0].price.quote,
          amount: tokenAmount,
          openTime: Date.now(),
        });
        this.seenTokens.add(token.token.mint);
        this.buyingTokens.delete(token.token.mint);
      } else {
        const position = this.positions.get(token.token.mint);
        if (position) {
          const exitPrice = token.pools[0].price.quote;
          const pnl = (exitPrice - position.entryPrice) * position.amount;
          const pnlPercentage =
            (pnl / (position.entryPrice * position.amount)) * 100;

          const soldPosition = {
            ...position,
            exitPrice,
            pnl,
            pnlPercentage,
            closeTime: Date.now(),
            closeTxid: txid,
          };

          this.soldPositions.push(soldPosition);

          logger.info(
            `Closed position for ${token.token.symbol}. PnL: (${pnlPercentage.toFixed(2)}%)`
          );
          this.positions.delete(token.token.mint);
          this.sellingPositions.delete(token.token.mint);

          await this.saveSoldPositions();
        }
      }

      await this.savePositions();
      return txid;
    } catch (error) {
      logger.error(
        `Error performing ${isBuy ? "buy" : "sell"}: ${error.message}`,
        { error }
      );
      if (isBuy) {
        this.buyingTokens.delete(token.token.mint);
      } else {
        this.sellingPositions.delete(token.token.mint);
      }
      return false;
    }
  }

  async checkAndSellPosition(tokenMint) {
    if (this.sellingPositions.has(tokenMint)) {
    //  logger.info(`Already selling position for ${tokenMint}, skipping`);
      return;
    }

    const position = this.positions.get(tokenMint);
    if (!position) return;

    const tokenData = await this.fetchTokenData(tokenMint);
    if (!tokenData) {
      logger.error(`Failed to fetch data for token ${tokenMint}`);
      return;
    }

    const currentPrice = tokenData.pools[0].price.quote;
    const pnlPercentage =
      ((currentPrice - position.entryPrice) / position.entryPrice) * 100;

    logger.info(
      `PnL for position [${position.symbol}] [${chalk[
        pnlPercentage > 0 ? "green" : "red"
      ](pnlPercentage.toFixed(2))}%]`
    );

    if (
      pnlPercentage <= this.config.maxNegativePnL ||
      pnlPercentage >= this.config.maxPositivePnL
    ) {
      const currentAmount = await this.getWalletAmount(
        this.keypair.publicKey.toBase58(),
        tokenMint
      );
      if (currentAmount !== null && currentAmount > 0) {
        this.sellingPositions.add(tokenMint);
        this.performSwap(tokenData, false).catch((error) => {
          logger.error(`Error selling position: ${error.message}`, { error });
          this.sellingPositions.delete(tokenMint);
        });
      } else {
        logger.warn(
          `No balance found for ${position.symbol}, removing from positions`
        );
        this.positions.delete(tokenMint);
        await this.savePositions();
      }
    }
  }

  async buyMonitor() {
    while (true) {
      const tokens = await this.fetchTokens();
      const filteredTokens = this.filterTokens(tokens);

      for (const token of filteredTokens) {
        if (!this.positions.has(token.token.mint) && !this.buyingTokens.has(token.token.mint)) {
          this.buyingTokens.add(token.token.mint);
          this.performSwap(token, true).catch((error) => {
            logger.error(`Error buying token: ${error.message}`, { error });
            this.buyingTokens.delete(token.token.mint);
          });
        }
      }

      await sleep(this.config.delay);
    }
  }

  async positionMonitor() {
    while (true) {
      const positionPromises = Array.from(this.positions.keys()).map(
        (tokenMint) => this.checkAndSellPosition(tokenMint)
      );
      await Promise.allSettled(positionPromises);
      await sleep(this.config.monitorInterval);
    }
  }

  buildSwapOptions() {
    return {
      sendOptions: { skipPreflight: true },
      confirmationRetries: 30,
      confirmationRetryTimeout: 1000,
      lastValidBlockHeightBuffer: 150,
      resendInterval: 1000,
      confirmationCheckInterval: 1000,
      commitment: "processed",
      jito: this.config.useJito ? { enabled: true, tip: 0.0001 } : undefined,
    };
  }

  logTransaction(txid, isBuy, token) {
    logger.info(
      `${isBuy ? chalk.green("[BOUGHT]") : chalk.red("[SOLD]")} ${
        token.token.symbol
      } [${txid}]`
    );
  }

  async loadSoldPositions() {
    try {
      const data = await fs.readFile(this.soldPositionsFile, "utf8");
      this.soldPositions = JSON.parse(data);
      logger.info(
        `Loaded ${this.soldPositions.length} sold positions from file`
      );
    } catch (error) {
      if (error.code !== "ENOENT") {
        logger.error("Error loading sold positions", { error });
      }
    }
  }

  async saveSoldPositions() {
    try {
      await fs.writeFile(
        this.soldPositionsFile,
        JSON.stringify(this.soldPositions, null, 2)
      );
      logger.info(`Saved ${this.soldPositions.length} sold positions to file`);
    } catch (error) {
      logger.error("Error saving sold positions", { error });
    }
  }
  
  async loadPositions() {
    try {
      const data = await fs.readFile(this.positionsFile, "utf8");
      const loadedPositions = JSON.parse(data);
      this.positions = new Map(Object.entries(loadedPositions));
      this.seenTokens = new Set(this.positions.keys());
      logger.info(`Loaded ${this.positions.size} positions from file`);
    } catch (error) {
      if (error.code !== "ENOENT") {
        logger.error("Error loading positions", { error });
      }
    }
  }

  async savePositions() {
    try {
      const positionsObject = Object.fromEntries(this.positions);
      await fs.writeFile(
        this.positionsFile,
        JSON.stringify(positionsObject, null, 2)
      );
      logger.info(`Saved ${this.positions.size} positions to file`);
    } catch (error) {
      logger.error("Error saving positions", { error });
    }
  }

  async start() {
    try {
    logger.info("Starting Trading Bot");
    await this.initialize();

    // Run buying and selling loops concurrently
    await Promise.allSettled([this.buyMonitor(), this.positionMonitor()]);
    } catch (error) {
      console.log("Error starting bot", error);
    }
  }
}

const bot = new TradingBot();
bot.start().catch((error) => console.error("Error in bot execution", error));

================
File: package.json
================
{
  "name": "solana-volume-bot",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "chalk": "4.1.0",
    "dotenv": "^16.4.5",
    "solana-swap": "^1.1.2",
    "winston": "^3.13.1"
  }
}

================
File: README.md
================
# Solana Trading Bot

A high-performance, automated trading bot for Solana tokens using the Solana Tracker API.
Supports Raydium (V4/CPMM), Pumpfun, Moonshot, Orca and Jupiter.

Includes two examples, one using HTTP requests and one using the more efficient and faster Data Streams (Websockets) from Solana Tracker.

![Screenshot of the Trading Bot](https://i.gyazo.com/afb12f6c358385f133fa4b95dba3c095.png)

## Features

- Automated buying and selling of Solana tokens
- Multi-token support
- Configurable trading parameters (liquidity, market cap, risk score)
- Real-time position monitoring and management
- Parallel execution of buying and selling operations
- Detailed logging with timestamps and color-coded actions
- Persistent storage of positions and transaction history

## Prerequisites

- Node.js (v14 or later recommended)
- npm (comes with Node.js)
- A Solana wallet with SOL
- API Key (Billing Token) from [Solana Tracker Data API](https://docs.solanatracker.io)

## Installation

1. Clone the repository:
```bash
git clone https://github.com/YZYLAB/solana-trading-bot.git
cd solana-trading-bot
```

2. Install dependencies:
```bash
npm install
```

3. Rename the .env.example and configure the bot.

## Usage

Run the bot with:

```bash
node index.js 
```

Or

```bash
node websocket.js
```

## Configuration

Adjust the settings in your `.env` file to customize the bot's behavior:

- AMOUNT: The amount of SOL to swap in each transaction
- DELAY: Delay between buying cycles (in milliseconds)
- MONITOR_INTERVAL: Interval for monitoring positions (in milliseconds)
- SLIPPAGE: Maximum allowed slippage (in percentage)
- PRIORITY_FEE: Priority fee for transactions
- JITO: Set to "true" to use Jito for transaction processing
- RPC_URL: Your Solana RPC URL
- API_KEY: Your Solana Tracker - [Data API Key](https://www.solanatracker.io/data-api)
- PRIVATE_KEY: Your wallet's private key
- MIN_LIQUIDITY / MAX_LIQUIDITY: Liquidity range for token selection
- MIN_MARKET_CAP / MAX_MARKET_CAP: Market cap range for token selection
- MIN_RISK_SCORE / MAX_RISK_SCORE: Risk score range for token selection
- REQUIRE_SOCIAL_DATA: Set to "true" to only trade tokens with social data
- MAX_NEGATIVE_PNL / MAX_POSITIVE_PNL: PnL thresholds for selling positions
- MARKETS: Comma-separated list of markets to trade on

## API Usage and Fees

This bot uses the Solana Tracker API. Please refer to [Solana Tracker's documentation](https://docs.solanatracker.io) for information about API usage and associated fees.

## Disclaimer

This bot is for educational purposes only. Use at your own risk. Always understand the code you're running and the potential financial implications of automated trading.

The goal of this project is to show the potential ways of using the Solana Tracker API.

## License

[MIT License](LICENSE)

## Contributing

Contributions, issues, and feature requests are welcome! Feel free to check the [issues page](https://github.com/YZYLAB/solana-trading-bot/issues).

## Support

If you find this project helpful, please consider giving it a ⭐️ on GitHub!

================
File: websocket.js
================
require("dotenv").config();
const { SolanaTracker } = require("solana-swap");
const { Keypair, PublicKey, Connection } = require("@solana/web3.js");
const bs58 = require("bs58");
const winston = require("winston");
const chalk = require("chalk");
const fs = require("fs").promises;
const WebSocketService = require("./services/ws");

const logger = winston.createLogger({
  level: "info",
  format: winston.format.combine(
    winston.format.timestamp({
      format: "YYYY-MM-DD HH:mm:ss",
    }),
    winston.format.printf(
      (info) => `${info.timestamp} ${info.level}: ${info.message}`
    )
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: "trading-bot.log" }),
  ],
});

class TradingBot {
  constructor() {
    this.config = {
      amount: parseFloat(process.env.AMOUNT),
      slippage: parseInt(process.env.SLIPPAGE),
      priorityFee: parseFloat(process.env.PRIORITY_FEE),
      useJito: process.env.JITO === "true",
      rpcUrl: process.env.RPC_URL,
      minLiquidity: parseFloat(process.env.MIN_LIQUIDITY) || 0,
      maxLiquidity: parseFloat(process.env.MAX_LIQUIDITY) || Infinity,
      minMarketCap: parseFloat(process.env.MIN_MARKET_CAP) || 0,
      maxMarketCap: parseFloat(process.env.MAX_MARKET_CAP) || Infinity,
      minRiskScore: parseInt(process.env.MIN_RISK_SCORE) || 0,
      maxRiskScore: parseInt(process.env.MAX_RISK_SCORE) || 10,
      requireSocialData: process.env.REQUIRE_SOCIAL_DATA === "true",
      maxNegativePnL: parseFloat(process.env.MAX_NEGATIVE_PNL) || -Infinity,
      maxPositivePnL: parseFloat(process.env.MAX_POSITIVE_PNL) || Infinity,
      markets: process.env.MARKETS?.split(",").map((m) => m.trim()) || ['raydium', 'orca', 'pumpfun', 'moonshot', 'raydium-cpmm'],
    };


    this.privateKey = process.env.PRIVATE_KEY;
    this.SOL_ADDRESS = "So11111111111111111111111111111111111111112";
    this.positions = new Map();
    this.positionsFile = "positions.json";
    this.soldPositionsFile = "sold_positions.json";
    this.soldPositions = [];
    this.seenTokens = new Set();
    this.buyingTokens = new Set();
    this.sellingPositions = new Set();

    this.connection = new Connection(this.config.rpcUrl);
    this.wsService = new WebSocketService(process.env.WS_URL);
  }

  async initialize() {
    this.keypair = Keypair.fromSecretKey(bs58.decode(this.privateKey));
    this.solanaTracker = new SolanaTracker(this.keypair, this.config.rpcUrl);
    await this.loadPositions();
    await this.loadSoldPositions();
    this.setupWebSocketListeners();
  }

  setupWebSocketListeners() {
    logger.info("Monitoring for new tokens");
    this.wsService.joinRoom('latest');
    this.wsService.on('latest', (data) => this.handleNewToken(data));

    // Setup listeners for existing positions
    for (const [tokenMint, position] of this.positions) {
      this.setupPriceListener(tokenMint, position.poolId);
    }
  }

  setupPriceListener(tokenMint, poolId) {
    this.wsService.joinRoom(`pool:${poolId}`);
    this.wsService.on(`pool:${poolId}`, (data) => this.handlePriceUpdate(tokenMint, data));
  }

  handleNewToken(token) {
    if (this.filterToken(token)) {
      this.seenTokens.add(token.token.mint);
      this.performSwap(token, true).catch((error) => {
        logger.error(`Error buying new token: ${error.message}`, { error });
      });
    }
  }

  handlePriceUpdate(tokenMint, data) {
    const position = this.positions.get(tokenMint);
    if (position && !this.sellingPositions.has(tokenMint)) {
      const currentPrice = data.price.quote;
      const pnlPercentage = ((currentPrice - position.entryPrice) / position.entryPrice) * 100;
  
      logger.info(
        `PnL for position [${position.symbol}] [${chalk[
          pnlPercentage > 0 ? "green" : "red"
        ](pnlPercentage.toFixed(2))}%]`
      );
  
      if (
        pnlPercentage <= this.config.maxNegativePnL ||
        pnlPercentage >= this.config.maxPositivePnL
      ) {
        this.sellingPositions.add(tokenMint);
        const token = {
          token: { mint: tokenMint, symbol: position.symbol },
          pools: [{ poolId: position.poolId, price: { quote: currentPrice } }]
        };
        this.performSwap(token, false).catch((error) => {
          logger.error(`Error selling position: ${error.message}`, { error });
          this.sellingPositions.delete(tokenMint);
        });
      }
    }
  }

  filterToken(token) {
    const pool = token.pools[0];
    const liquidity = pool.liquidity.usd;
    const marketCap = pool.marketCap.usd;
    const riskScore = token.risk.score;
    const hasSocialData = !!(
      token.token.twitter ||
      token.token.telegram ||
      token.token.website
    );
    const isInAllowedMarket = this.config.markets.includes(pool.market);

    return (
      liquidity >= this.config.minLiquidity &&
      liquidity <= this.config.maxLiquidity &&
      marketCap >= this.config.minMarketCap &&
      marketCap <= this.config.maxMarketCap &&
      riskScore >= this.config.minRiskScore &&
      riskScore <= this.config.maxRiskScore &&
      (!this.config.requireSocialData || hasSocialData) &&
      isInAllowedMarket &&
      !this.seenTokens.has(token.token.mint) &&
      !this.buyingTokens.has(token.token.mint)
    );
  }

  async performSwap(token, isBuy) {
    logger.info(
      `${
        isBuy ? chalk.white("[BUYING]") : chalk.white("[SELLING]")
      } [${this.keypair.publicKey.toBase58()}] [${token.token.symbol}] [${
        token.token.mint
      }]`
    );
    const { amount, slippage, priorityFee } = this.config;
    const [fromToken, toToken] = isBuy
      ? [this.SOL_ADDRESS, token.token.mint]
      : [token.token.mint, this.SOL_ADDRESS];

    try {
      let swapAmount;
      if (isBuy) {
        swapAmount = amount;
      } else {
        const position = this.positions.get(token.token.mint);
        if (!position) {
          logger.error(
            `No position found for ${token.token.symbol} when trying to sell`
          );
          return false;
        }
        swapAmount = position.amount;
      }

      const swapResponse = await this.solanaTracker.getSwapInstructions(
        fromToken,
        toToken,
        swapAmount,
        slippage,
        this.keypair.publicKey.toBase58(),
        priorityFee
      );

      const swapOptions = this.buildSwapOptions();
      const txid = await this.solanaTracker.performSwap(
        swapResponse,
        swapOptions
      );
      this.logTransaction(txid, isBuy, token);

      if (isBuy) {
        const tokenAmount = await this.getWalletAmount(
          this.keypair.publicKey.toBase58(),
          token.token.mint
        );
        if (!tokenAmount) {
          logger.error(
            `Swap failed ${token.token.mint}`
          );
          return false;
        }
        this.positions.set(token.token.mint, {
          txid,
          poolId: token.pools[0].poolId,
          symbol: token.token.symbol,
          entryPrice: token.pools[0].price.quote,
          amount: tokenAmount,
          openTime: Date.now(),
        });
        this.buyingTokens.delete(token.token.mint);
        this.setupPriceListener(token.token.mint, token.pools[0].poolId);
      } else {
        const position = this.positions.get(token.token.mint);
        if (position) {
          const exitPrice = token.pools[0].price.quote;
          const pnl = (exitPrice - position.entryPrice) * position.amount;
          const pnlPercentage =
            (pnl / (position.entryPrice * position.amount)) * 100;

          const soldPosition = {
            ...position,
            exitPrice,
            pnl,
            pnlPercentage,
            closeTime: Date.now(),
            closeTxid: txid,
          };

          this.soldPositions.push(soldPosition);

          logger.info(
            `Closed position for ${token.token.symbol}. PnL: (${pnlPercentage.toFixed(2)}%)`
          );
          this.positions.delete(token.token.mint);
          this.sellingPositions.delete(token.token.mint);
          this.wsService.leaveRoom(`pool:${position.poolId}`);

          await this.saveSoldPositions();
        }
      }

      await this.savePositions();
      return txid;
    } catch (error) {
      logger.error(
        `Error performing ${isBuy ? "buy" : "sell"}: ${error.message}`,
        { error }
      );
      if (isBuy) {
        this.buyingTokens.delete(token.token.mint);
      } else {
        this.sellingPositions.delete(token.token.mint);
      }
      return false;
    }
  }

  buildSwapOptions() {
    return {
      sendOptions: { skipPreflight: true },
      confirmationRetries: 30,
      confirmationRetryTimeout: 1000,
      lastValidBlockHeightBuffer: 150,
      resendInterval: 1000,
      confirmationCheckInterval: 1000,
      commitment: "processed",
      jito: this.config.useJito ? { enabled: true, tip: 0.0001 } : undefined,
    };
  }

  logTransaction(txid, isBuy, token) {
    logger.info(
      `${isBuy ? chalk.green("[BOUGHT]") : chalk.red("[SOLD]")} ${
        token.token.symbol
      } [${txid}]`
    );
  }

  async getWalletAmount(wallet, mint, retries = 3) {
    for (let attempt = 0; attempt <= retries; attempt++) {
      try {
        const tokenAccountInfo =
          await this.connection.getParsedTokenAccountsByOwner(
            new PublicKey(wallet),
            {
              mint: new PublicKey(mint),
            }
          );

        if (tokenAccountInfo.value) {
          const balance =
            tokenAccountInfo.value[0].account.data.parsed.info.tokenAmount
              .uiAmount;

          if (balance > 0) {
            return balance;
          }
        }

        if (attempt < retries) {
          await new Promise(resolve => setTimeout(resolve, 10000));
        }
      } catch (error) {
        if (attempt < retries) {
          await new Promise(resolve => setTimeout(resolve, 10000));
        } else {
          logger.error(
            `All attempts failed. Error getting wallet amount for token ${mint}:`,
            error
          );
        }
      }
    }

    logger.warn(
      `Failed to get wallet amount for token ${mint} after ${retries} retries.`
    );
    return null;
  }

  async loadSoldPositions() {
    try {
      const data = await fs.readFile(this.soldPositionsFile, "utf8");
      this.soldPositions = JSON.parse(data);
      logger.info(
        `Loaded ${this.soldPositions.length} sold positions from file`
      );
    } catch (error) {
      if (error.code !== "ENOENT") {
        logger.error("Error loading sold positions", { error });
      }
    }
  }

  async saveSoldPositions() {
    try {
      await fs.writeFile(
        this.soldPositionsFile,
        JSON.stringify(this.soldPositions, null, 2)
      );
      logger.info(`Saved ${this.soldPositions.length} sold positions to file`);
    } catch (error) {
      logger.error("Error saving sold positions", { error });
    }
  }
  
  async loadPositions() {
    try {
      const data = await fs.readFile(this.positionsFile, "utf8");
      const loadedPositions = JSON.parse(data);
      this.positions = new Map(Object.entries(loadedPositions));
      this.seenTokens = new Set(this.positions.keys());
      logger.info(`Loaded ${this.positions.size} positions from file`);
    } catch (error) {
      if (error.code !== "ENOENT") {
        logger.error("Error loading positions", { error });
      }
    }
  }

  async savePositions() {
    try {
      const positionsObject = Object.fromEntries(this.positions);
      await fs.writeFile(
        this.positionsFile,
        JSON.stringify(positionsObject, null, 2)
      );
      logger.info(`Saved ${this.positions.size} positions to file`);
    } catch (error) {
      logger.error("Error saving positions", { error });
    }
  }

  async start() {
    logger.info("Starting Trading Bot");
    await this.initialize();
  }
}

const bot = new TradingBot();
bot.start().catch((error) => logger.error("Error in bot execution", { error }));
